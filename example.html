<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Example</title>
	<style>
		html,body{margin: 0;}
	</style>
</head>
<body>
	<div id="canvas"></div>

	<script src="./src/three.min.js"></script>
	<script src="./src/OrbitControls.js"></script>
	<script src="./src/cannon.min.js"></script>
	<!-- <script src="./src/cannon.demo.js"></script>
	<script src="./src/Detector.js"></script>
	<script src="./src/smoothie.js"></script>
	<script src="./src/Stats.js"></script>
	<script src="./src/TrackballControls.js"></script>
	<script src="./src/dat.gui.js"></script>
	<script src="./src/scenejs.js"></script> -->
	<script>
	requestAnimationFrame = window.requestAnimationFrame ||
													window.mozRequestAnimationFrame ||
													window.webkitRequestAnimationFrame ||
													window.msRequestAnimationFrame;
	window.requestAnimationFrame = requestAnimationFrame;

	window.addEventListener("DOMContentLoaded", function(){
		var camera,scene,renderer,groundBody,world,
				canvas     = document.getElementById("canvas"),
				width      = canvas.clientWidth,
				height     = window.innerHeight;

		var planeX = 50,planeY = 50,
				cubeSize = 7,sphereSize = 1,
				sphereArr = [],cubeData = [],
				countPhy = 0,
				phyGround;

		initPhy();
		init();
		animate();

		cubeInterval = setInterval(function(){
			sphereArr.push({
				phy: createPhySphere(),
				sphere: createSphere()
			});
			countPhy++;
			if(countPhy === 200) clearInterval(cubeInterval);
		},100);

		/**
		 * Cannon init
		*/
		function initPhy(){
			world = new CANNON.World();// worldを生成
			world.broadphase = new CANNON.NaiveBroadphase();// 衝突している可能性のある剛体を見つける
			world.gravity.set( 0, -9.82, 0 );// 重力の設定
			// world.solver.iterations = 100;
			world.solver.tolerance = 0.001;
			
			/*
			 * 物理演算対象の剛体[地面]を生成
			*/
			// var ground,groundBody;
			// ground = new CANNON.Plane();//　地面の生成
			// groundBody = new CANNON.Body( {mass: 0} );// 質量0の剛体を生成
			// groundBody.addShape(ground);// bodyに追加
			// groundBody.quaternion.setFromAxisAngle( new CANNON.Vec3( 1, 0, 0 ), -Math.PI / 2 );// x軸から90度回転
			// world.add( groundBody );// worldに剛体を追加

			phyGround = new CANNON.Body({mass: 0});
			var matrix = [];
			for (var i = 0; i < planeX; i++) {
				matrix.push([]);
				for (var j = 0; j < planeY; j++) {
					var height = Math.cos(i / planeX * Math.PI * 5) * Math.cos(j/planeY * Math.PI * 5) * 2 + 2;
					if(i===0 || i === planeX-1 || j===0 || j === planeY-1) height = 0;
					matrix[i].push(height);
				}
			}
			phyGround.addShape(new CANNON.Heightfield(matrix, {
				elementSize: planeX*2 / planeX
			}));
			// X軸に90度回転
			phyGround.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
			phyGround.position.y = -1;
			phyGround.position.x = -planeX;
			phyGround.position.z = planeX;
			// 世界に追加
			world.add(phyGround);


			/*
			 * 物理演算対象の剛体[キューブ]を生成
			*/
			var phyCube,phyCubeBody,
					space = 15,x = -space,z = -(space*2);

			phyCube = new CANNON.Box( new CANNON.Vec3( cubeSize/2, cubeSize/2, cubeSize/2 ) );// キューブの生成
			for(var i = 0;i < 9;i++){
				if(i % 3 == 0){
					z = z+space;
					x = -space;
				}
				phyCubeBody = new CANNON.Body( {mass: 0} );// 質量1の剛体を生成
				phyCubeBody.addShape( phyCube );// bodyに追加
				phyCubeBody.position.set( x, 20, z );
				phyCubeBody.quaternion.z = Math.random() * 1 - 0.5;
				cubeData.push(phyCubeBody);
				world.add(phyCubeBody);
				x = x+space;
			}
		}
		/**
		 * 物理演算対象の剛体(sphere)を生成
		*/
		function createPhySphere(){
			var sphere,sphereBody;
			sphere = new CANNON.Sphere( sphereSize );// キューブの生成
			sphereBody = new CANNON.Body( {mass: 1} );// 質量1の剛体を生成
			sphereBody.addShape( sphere );// bodyに追加
			sphereBody.position.x = Math.random() * 20 - 10;
			sphereBody.position.y = 40;
			sphereBody.position.z = Math.random() * 20 - 10;
			world.add(sphereBody);
			return sphereBody;
		}
		/**
		 * three init
		 * @return undefined
		*/
		function init(){
			// カメラの設定
			camera = new THREE.PerspectiveCamera( 45, width/height, 1, 1000 );// カメラの作成
			camera.position.set( 0, 50, 100 );// カメラの位置設定
			controls = new THREE.OrbitControls(camera, canvas);
			controls.addEventListener("change", render);

			scene     = new THREE.Scene();// シーンの作成
			// scene.fog = new THREE.FogExp2( 0xABABAB, 0.008 );// シーンにぼかしを追加

			/*
			 * 地面
			*/
			// var planeGeo,planeMaterial,planeMesh,texture;
			// planeGeo = new THREE.PlaneGeometry( planeX, planeY, 16, 16 );// ジオメトリーの作成
			// // for(var i = 0;i < planeGeo.vertices.length;i++){// ジオメトリの頂点分ループし、z方向の値を変更する
			// // 	planeGeo.vertices[i].z = Math.random() * 10 - 10;
			// // }
			// texture              = THREE.ImageUtils.loadTexture( "./images/plane.png", {}, function(){renderer.render( scene, camera );} );// 画像の読み込み
			// planeMaterial        = new THREE.MeshBasicMaterial({map: texture});// マテリアルの作成
			// planeMesh            = new THREE.Mesh( planeGeo, planeMaterial );// メッシュの作成
			// planeMesh.rotation.x = -Math.PI / 2;// x軸を-90度回転
			// scene.add( planeMesh );// メッシュをシーンに追加

			texture = THREE.ImageUtils.loadTexture( "./images/plane.png", {}, function(){renderer.render( scene, camera );} );// 画像の読み込み
			// var material = new THREE.MeshPhongMaterial({
   //        color: 0x000000,
   //        specular: 0xffffff,
   //        shininess: 0
   //    });
			var material = new THREE.MeshBasicMaterial({map: texture});
      // var viewGround = new THREE.Object3D();
      var viewGround = new THREE.Object3D();
      for (var l = 0; l < phyGround.shapes.length; l++) {
          var shape = phyGround.shapes[l];
          var geometry = new THREE.Geometry();
          // var geometry = new THREE.PlaneGeometry( planeX, planeY, 16, 16 );
          var v0 = new CANNON.Vec3();
          var v1 = new CANNON.Vec3();
          var v2 = new CANNON.Vec3();
          for (var xi = 0; xi < shape.data.length - 1; xi++) {
              for (var yi = 0; yi < shape.data[xi].length - 1; yi++) {
                  for (var k = 0; k < 2; k++) {
                      shape.getConvexTrianglePillar(xi, yi, k===0);
                      v0.copy(shape.pillarConvex.vertices[0]);
                      v1.copy(shape.pillarConvex.vertices[1]);
                      v2.copy(shape.pillarConvex.vertices[2]);
                      v0.vadd(shape.pillarOffset, v0);
                      v1.vadd(shape.pillarOffset, v1);
                      v2.vadd(shape.pillarOffset, v2);
                      geometry.vertices.push(
                              new THREE.Vector3(v0.x, v0.y, v0.z),
                              new THREE.Vector3(v1.x, v1.y, v1.z),
                              new THREE.Vector3(v2.x, v2.y, v2.z)
                      );
                      geometry.faceVertexUvs[0].push([
												new THREE.Vector2(  0,  1  ),    // TL
												new THREE.Vector2(  0,  0  ),    // BL
												new THREE.Vector2(  1,  1  )
											]);
                      var i = geometry.vertices.length - 3;
                      geometry.faces.push(new THREE.Face3(i, i+1, i+2));
                  }
              }
          }
          geometry.computeBoundingSphere();
          geometry.computeFaceNormals();
          var mesh = new THREE.Mesh(geometry, material);
          mesh.receiveShadow = true;
          mesh.castShadow = true;
          if(mesh.children){
              for(var i=0; i<mesh.children.length; i++){
                  mesh.children[i].castShadow = true;
                  mesh.children[i].receiveShadow = true;
                  if(mesh.children[i]){
                      for(var j=0; j<mesh.children[i].length; j++){
                          mesh.children[i].children[j].castShadow = true;
                          mesh.children[i].children[j].receiveShadow = true;
                      }
                  }
              }
          }
          viewGround.add(mesh);
      }
      viewGround.position.copy(phyGround.position);
      viewGround.quaternion.copy(phyGround.quaternion);
      scene.add(viewGround);

      /*
       * ライトの設定
      */
      var light = new THREE.SpotLight(0x999999);
      light.position.set(0, 1000, 1);
      light.castShadow = true;
      light.shadowMapWidth = 1024;
      light.shadowMapHeight = 1024;
      light.shadowCameraNear = 500;
      light.shadowCameraFar = 4000;
      light.shadowCameraFov = 30;
      scene.add(light);
      var pointhelper = new THREE.PointLightHelper(light, 1);
      scene.add(pointhelper);

			/*
			 * キューブ
			*/
			var cubeGeo,cubeMaterial,cubeMesh;
			cubeGeo = new THREE.BoxGeometry( cubeSize, cubeSize, cubeSize );// ジオメトリーの作成
			cubeMaterial        = new THREE.MeshBasicMaterial({color: 0xffffff});// マテリアルの作成
			for(var i = 0;i < 9;i++){
				cubeMesh            = new THREE.Mesh( cubeGeo, cubeMaterial );// メッシュの作成
				cubeMesh.rotation.z = cubeData[i].quaternion.z;
				cubeMesh.position.set( cubeData[i].position.x, cubeData[i].position.y, cubeData[i].position.z );
				cubeMesh.castShadow = true;
				scene.add( cubeMesh );// メッシュをシーンに追加
			}

			renderer = new THREE.WebGLRenderer({antialias:true});// レンダラーの作成
			renderer.setSize( width, height );// 描画サイズ
			// renderer.setClearColor( 0xffffff );// 描画カラー
			renderer.setClearColor( 0xABABAB );// 描画カラー
			renderer.shadowMapEnabled = true;
			canvas.appendChild( renderer.domElement );// canvasに描画コンテンツを追加
			render();// 描画
		}
		/**
		 * create sphere object
		 * @return sphereMesh {object} sphere mesh object
		*/
		function createSphere(){
			var sphereGeo,sphereMaterial,sphereMesh;
			sphereGeo = new THREE.SphereGeometry( sphereSize, 32, 32);
			// sphereMaterial = new THREE.MeshBasicMaterial({color: 0xe57373});
			sphereMaterial = new THREE.MeshLambertMaterial({side: THREE.DoubleSide,color: 0xe57373});
			sphereMesh = new THREE.Mesh( sphereGeo,sphereMaterial );
			// sphereMesh.castShadow = true;
			sphereMesh.receiveShadow = true; 
			scene.add( sphereMesh );
			return sphereMesh;
		}
		function animate() {
			requestAnimationFrame(animate);
			world.step(1 / 60);// 物理エンジンの時間を進める
			for(var i = 0;i < sphereArr.length;i++){
				sphereArr[i].sphere.position.copy(sphereArr[i].phy.position);
				sphereArr[i].sphere.quaternion.copy(sphereArr[i].phy.quaternion);
			}
			render();
		}
		/**
		 * canvas render func
		 * @return undefined
		*/
		function render(){
			renderer.render( scene, camera );
		}
	});
	</script>
</body>
</html>